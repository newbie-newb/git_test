int bin_coef_DC(int n, int k) {
    if (k==0 || k==n) return 1;
    return bin_coef_DC(n-1, k-1) + bin_coef_DC(n-1, k);
}



int bin_coef_DP(int n, int k) {
        int C[MAX][MAX];
        int i, j, m;
        for (i = 0; i <= n; i++) {
            m = minimum(i, k);
            for (j = 0; j <= m; j++) {
                if (j == 0 || j == i) C[i][j] = 1;
                else C[i][j] = C[i-1][j-1] + C[i-1][j];
            }
        }
        return C[n][k];
    }
    
int coin_change_making_DP(int W[ ], int n, int M) {
            int C[MAX]={0}, i, k;
            for (i = 10; i <= M; i = i+10)
                for (C[i]=∞, k = 1; k <= n; k++)
                    if (i >= W[k] && C[i-W[k]]+1 < C[i])
                        C[i] = C[i-W[k]] + 1;
            return C[M];
        }
                
                
                


                
                
  
int coin_change_making_DP(int W[ ], int n, int M) {
    int C[MAX]={0}, i, k;
    int B[MAX]={0};
    for (i = 10; i <= M; i = i+10)
        for (C[i]=∞, k = 1; k <= n; k++)
            if (i >= W[k] && C[i-W[k]]+1 < C[i]) {
                C[i] = C[i-W[k]] + 1;
                B[i] = i-W[k];
            }
    return C[M];
}

// CC[MAX]={0}와 B[]는 전역변수
void count_coins() {
    int i = M;
    while(i>0) {
        CC[(i-B[i])]++;
        i = B[i];
    }
}

// CC[MAX]={0}와 B[]는 전역변수, i=M으로 호춣
void count_coins_R(int i) {
    CC[(i-B[i])]++;
    count_coins_R(i-B[i]);
}